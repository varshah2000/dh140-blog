{
  
    
        "post0": {
            "title": "DH 140 Final Project: Inside the Scooby-Doo Verse",
            "content": "A a data analysis project by UCLA Digital Humanities student Varsha Hunter. . Date: March 14, 2022 . Introduction . This project aims to explore the Scooby-Doo universe and answer some controversial questions about the Gang and their adventures capturing monsters and villains. . Research Question: Who is the strongest and weakest link among the Gang? . The Scooby-Doo Gang consists of five total members: Fred, Velma, Daphne, Shaggy, and Scooby-Doo. Fans of Scooby-Doo have their favorites for numerous reasons, however many may argue who is the strongest link and who is the weakest link among the gang. Is Velma the strongest because she is the smartest? Or is she the weakest because of her bad eyesight? Or is Fred the strongest due to his leadership qualities? Or is he the weakest because he brings nothing else to the table? This project may bring about controversy because the answer may not be what we expect due to personal opinions. However, we aim to answer this question using different metrics such as: the number of times each character has been abducted by a villain, the number of snacks they consume in an episode, and the number of villains they&#39;ve captured themselves. Hopefully after our extensive analysis, we&#39;re able to come to a decisive conclusion. . Project Scope . The goal of our project is to answer our research question through statistical analysis and visualizations using variables provided within the data. In addition to our research question, here are some supplementary questions we aim to answer in our analysis: . Do Scooby Snacks improve the capabilities of each Gang member? In other words, does Scooby Snack consumption boost one&#39;s ability to capture villains? | Which Gang member captures the most monsters? Which Gang member captures the least? | . Methods . Here we introduce our data and explain the methodology of our analysis. . Looking at the Data: . This dataset was originally created by plummye and shared on Kaggle. However, I accessed the dataset in the form of a csv from Data.World. . Here is a link to the dataset where all variables are explained and the csv can be downloaded: https://data.world/amberthomas/scooby-doo-tv-episodes-movies. . Data Preview . # imports import pandas as pd . . # Loading the Data og_scooby_df = pd.read_csv(&#39;scoobydoo.csv&#39;) #Selecting rows relevant to TV series only scooby_df = og_scooby_df.loc[(og_scooby_df[&#39;format&#39;] ==&#39;TV Series&#39;)| (og_scooby_df[&#39;format&#39;] == &#39;TV Series (segmented)&#39;) | (og_scooby_df[&#39;format&#39;] == &#39;Crossover&#39;)] scooby_df.head(5) . . index series_name network season title imdb engagement date_aired run_time format ... batman scooby_dum scrappy_doo hex_girls blue_falcon fred_va daphnie_va velma_va shaggy_va scooby_va . 0 1 | Scooby Doo, Where Are You! | CBS | 1 | What a Night for a Knight | 8.1 | 556.0 | 1969-09-13 | 21 | TV Series | ... | False | False | False | False | False | Frank Welker | Stefanianna Christopherson | Nicole Jaffe | Casey Kasem | Don Messick | . 1 2 | Scooby Doo, Where Are You! | CBS | 1 | A Clue for Scooby Doo | 8.1 | 479.0 | 1969-09-20 | 22 | TV Series | ... | False | False | False | False | False | Frank Welker | Stefanianna Christopherson | Nicole Jaffe | Casey Kasem | Don Messick | . 2 3 | Scooby Doo, Where Are You! | CBS | 1 | Hassle in the Castle | 8.0 | 455.0 | 1969-09-27 | 21 | TV Series | ... | False | False | False | False | False | Frank Welker | Stefanianna Christopherson | Nicole Jaffe | Casey Kasem | Don Messick | . 3 4 | Scooby Doo, Where Are You! | CBS | 1 | Mine Your Own Business | 7.8 | 426.0 | 1969-10-04 | 21 | TV Series | ... | False | False | False | False | False | Frank Welker | Stefanianna Christopherson | Nicole Jaffe | Casey Kasem | Don Messick | . 4 5 | Scooby Doo, Where Are You! | CBS | 1 | Decoy for a Dognapper | 7.5 | 391.0 | 1969-10-11 | 21 | TV Series | ... | False | False | False | False | False | Frank Welker | Stefanianna Christopherson | Nicole Jaffe | Casey Kasem | Don Messick | . 5 rows × 75 columns . This dataset has 75 columns or variables that represent different attributes for the characters, villains, ratings and more for every episode &amp; movie within the Scooby Doo universe. We limited our dataset to only showcase the rows that pertained to the TV episode/series and excluded the movies for simplicity in our analysis. . For our analysis, we will focus on these variables only: . format: the media format (TV Episode) | monster_real: yes/no value that represents whether the monster was real or fake (human or not) | caught_fred, caught_daphne, caught_velma, caught_shaggy, caught_scooby: whether the monster was caught by said Gang member | captured_fred, captured_daphne, captured_velma,captured_shaggy, captured_scooby: whether the monster abducted/kidnapped said Gang member | snack_fred, snack_daphne, snack_shaggy, snack_velma, snack_scooby: whether a scooby snack was eaten by said Gang member | number_of_snacks: number of Scooby snacks eaten within an episode/movie | . Methodology: . In order to answer our research question, we conducted an exploratory analysis to get an understanding of the data. We first answered these general questions in our EDA: . What is the frequency of real and fake monsters within the Scooby Doo verse? Are most monsters fake or real? | What is the mode number of snacks consumed in the series? | Who has consumed the most Scooby snacks over the course of the series? Who has consumed the least? | . After answering these general questions, we moved onto finding an answer to our research question: Which member is the strongest and weakest link among the Gang? To answer this question, we determined: . The number of times each Gang member has been abducted by a real and fake Monster in total over the course of the series | Determining the Rate of Successful Fake &amp; Real Monsters by each Gang member | The number of snacks each Gang member has consumed vs. the number of monsters they&#39;ve captured over the course of the series | . Results . Here we conduct our EDA, provide visuals, and answer the questions pertaining to our research question. . EDA . # imports import matplotlib.pyplot as plt import matplotlib.patches as mpatches import numpy as np . . In our exploration of the data, we looked at the summary statistics for both episode imdb score and episode engagement in order to gage audience attitudes towards the series: . # Summary Statistics stats_df = scooby_df[[&#39;imdb&#39;,&#39;engagement&#39;, &#39;monster_real&#39;, &#39;caught_fred&#39;, &#39;caught_daphnie&#39;, &#39;caught_velma&#39;, &#39;caught_shaggy&#39;, &#39;caught_scooby&#39;, &#39;captured_fred&#39;, &#39;captured_daphnie&#39;, &#39;captured_velma&#39;, &#39;captured_scooby&#39;, &#39;captured_shaggy&#39;, &#39;snack_fred&#39;, &#39;snack_daphnie&#39;, &#39;snack_velma&#39;, &#39;snack_shaggy&#39;, &#39;snack_scooby&#39;, &#39;number_of_snacks&#39;]] stats_df.describe() . . imdb engagement . count 542.000000 | 542.000000 | . mean 7.353137 | 97.953875 | . std 0.682024 | 307.695098 | . min 4.600000 | 7.000000 | . 25% 7.100000 | 26.000000 | . 50% 7.400000 | 47.000000 | . 75% 7.700000 | 101.000000 | . max 9.600000 | 6929.000000 | . As we can see, the average IMDB episode rating is 7.35 and the average user engagement is 97.95. In other words, audiences rate Scooby-Doo on average 7.35/10 and each episode gains approximately 98 reviews. The max amount of reviews left for an episode is 6929 and the max rating for an episode is 9.60. This lets us know that audiences have relatively positive opinions about the series and the gang members. We explore our data further below: . What is the frequency of real and fake monsters within the Scooby Doo verse? Are most monsters fake or real? . # Number of Real &amp; Fake Monsters real_monsters = scooby_df[&#39;monster_real&#39;].sum() fake_monsters = len(scooby_df[&#39;monster_real&#39;]) - real_monsters . . # Plotting Bar Chart fig = plt.figure() ax = fig.add_axes([0, 0, 1, 1]) real_fake_monsters = [&#39;Real Monsters&#39;, &#39;Fake Monsters&#39;] number_real_fake_monsters = [real_monsters, fake_monsters] ax.bar(real_fake_monsters, number_real_fake_monsters, color = &#39;blue&#39;) plt.title(&#39;Number of Real and Fake Monsters within Scooby-Doo Verse&#39;) plt.ylabel(&#39;Count&#39;) plt.show() . . According to our data, there are more fake monsters than real monsters in the Scooby-Doo universe. These &#39;fake&#39; monsters are typically humans parading as real monsters as a result of some motive. There are numerous motives such as Theft, Anger, and Competition but we do not explore these different motives in our analysis as it is not relevant to our research question. Real monsters within the universe are known to be Ghosts, Animals, or Mythical creatures, etc. however we do not explore these different monster types either in our analysis. . What is mode number of snacks consumed in the series? . # Number of Snacks &amp; Their Labels number_snacks = scooby_df[&#39;number_of_snacks&#39;].value_counts()[1:] snack_labels = [&#39;1&#39;, &#39;1 box&#39;, &#39;several&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;a couple&#39;, &#39;5&#39;, &#39;6&#39;, &#39;2 boxes&#39;, &#39;3 boxes&#39;, &#39;truck load&#39;, &#39;lifetime supply&#39;, &#39;8&#39;, &#39;several boxes&#39;] . . # Plotting fig = plt.figure() ax = fig.add_axes([0, 0, 1, 1]) ax.bar(snack_labels, number_snacks, color = &#39;blue&#39;) plt.xticks(rotation = 90) plt.xlabel(&#39;Number of Scooby Snacks&#39;) plt.ylabel(&#39;Count&#39;) plt.title(&#39;Number of Scooby Snacks Consumed in the Series&#39;) . . Text(0.5, 1.0, &#39;Number of Scooby Snacks Consumed in the Series&#39;) . Looking within the data, the mode number of Scooby Snacks consumed in the series is 1. In other words, we typically see one gang member eating at least 1 scooby snack per episode in the series. . Who has consumed the most Scooby snacks over the course of the series? Who has consumed the least? . # Fred fred_snacks = scooby_df[&#39;snack_fred&#39;].sum() # Daphne daphne_snacks = scooby_df[&#39;snack_daphnie&#39;].sum() # Velma velma_snacks = scooby_df[&#39;snack_velma&#39;].sum() #Shaggy shaggy_snacks = scooby_df[&#39;snack_shaggy&#39;].sum() #Scooby scooby_snacks = scooby_df[&#39;snack_scooby&#39;].sum() . . #Plotting the_gang = [&#39;Fred&#39;, &#39;Daphne&#39;, &#39;Velma&#39;, &#39;Shaggy&#39;, &#39;Scooby&#39;] snack_consumption = [fred_snacks, daphne_snacks, velma_snacks, shaggy_snacks, scooby_snacks] fig = plt.figure() ax = fig.add_axes([0,0,1,1]) ax.bar(the_gang, snack_consumption, color = &#39;blue&#39;) plt.title(&#39;Number of Scooby Snacks Each Gang Member Has Eaten&#39;) plt.ylabel(&#39;Count&#39;) . . Text(0, 0.5, &#39;Count&#39;) . Shockingly, Daphne consumes the most Scooby Snacks over the course of the series and Scooby consumes the least. . Focused Analysis: Answering our Research Question . Here we answer the questions that will guide us to reveal the truths of our research question: Who is the strongest and weakest link among the Scooby-Doo Gang? . Determining the number of times each Gang member has been abducted by Real and Fake Monsters in the Scooby-Doo Verse . ## Captured by Real Monsters real_monster_df = scooby_df.loc[scooby_df[&#39;monster_real&#39;] == True] # Fred fred_abducted_real = real_monster_df[&#39;captured_fred&#39;].sum() # Daphne daphne_abducted_real = real_monster_df[&#39;captured_daphnie&#39;].sum() # Velma velma_abducted_real = real_monster_df[&#39;captured_velma&#39;].sum() # Shaggy shaggy_abducted_real = real_monster_df[&#39;captured_shaggy&#39;].sum() #Scooby scooby_abducted_real = real_monster_df[&#39;captured_scooby&#39;].sum() . . ## Captured by Fake Monsters fake_monster_df = scooby_df.loc[scooby_df[&#39;monster_real&#39;] == False] # Fred fred_abducted_fake = fake_monster_df[&#39;captured_fred&#39;].sum() # Daphne daphne_abducted_fake = fake_monster_df[&#39;captured_daphnie&#39;].sum() # Velma velma_abducted_fake = fake_monster_df[&#39;captured_velma&#39;].sum() # Shaggy shaggy_abducted_fake = fake_monster_df[&#39;captured_shaggy&#39;].sum() #Scooby scooby_abducted_fake = fake_monster_df[&#39;captured_shaggy&#39;].sum() . . real_abductions = [fred_abducted_real, daphne_abducted_real, velma_abducted_real, shaggy_abducted_real, scooby_abducted_real] fake_abductions = [fred_abducted_fake, daphne_abducted_fake, velma_abducted_fake, shaggy_abducted_fake, scooby_abducted_fake] x_axis = np.arange(len(the_gang)) plt.bar(x_axis - 0.2, real_abductions, 0.4, label = &#39;Real&#39;) plt.bar(x_axis + 0.2, fake_abductions, 0.4, label = &#39;Fake&#39;) plt.xticks(x_axis, the_gang) plt.ylabel(&#39;Count&#39;) plt.title(&#39;Number of Abductions by Fake &amp; Real Monsters&#39;) plt.legend(loc = &#39;upper left&#39;) plt.show() . . According to our visualization, it appears that Scooby Doo gets abducted by Real Monsters more often than any other gang member. On the other hand, Daphne appears to get abducted the most by Fake Monsters. This is a significant finding because Fake monsters are humans in disguise, while Real monsters are some supernatural entity. We presume that dealing with Real monsters is significantly more difficult than dealing with Fake monsters because of their supernatural abilities. Therefore, this finding shows that Daphne may be the weakest linkest since she is one of the members that is most often captured by Fake monsters &amp; is the 3rd gang member to get abducted most often by Real Monsters. However, we continue our analysis below before coming to a decisive conclusion. . Determining the Rate of Successful Fake &amp; Real Monsters by each Gang member . # Fred fred_captured_real = real_monster_df[&#39;caught_fred&#39;].sum() fred_real_rate = (fred_captured_real / len(real_monster_df)) * 100 # Daphne daphne_captured_real = real_monster_df[&#39;caught_daphnie&#39;].sum() daphne_real_rate = (daphne_captured_real / len(real_monster_df)) * 100 # Velma velma_captured_real = real_monster_df[&#39;caught_velma&#39;].sum() velma_real_rate = (velma_captured_real / len(real_monster_df)) * 100 # Shaggy shaggy_captured_real = real_monster_df[&#39;caught_shaggy&#39;].sum() shaggy_real_rate = (shaggy_captured_real / len(real_monster_df)) * 100 #Scooby scooby_captured_real = real_monster_df[&#39;caught_scooby&#39;].sum() scooby_real_rate = (scooby_captured_real / len(real_monster_df)) * 100 . . # Fred fred_captured_fake = fake_monster_df[&#39;caught_fred&#39;].sum() fred_fake_rate = (fred_captured_fake / len(fake_monster_df)) * 100 # Daphne daphne_captured_fake = fake_monster_df[&#39;caught_daphnie&#39;].sum() daphne_fake_rate = (daphne_captured_fake / len(fake_monster_df)) * 100 # Velma velma_captured_fake = fake_monster_df[&#39;caught_velma&#39;].sum() velma_fake_rate = (velma_captured_fake / len(fake_monster_df)) * 100 # Shaggy shaggy_captured_fake = fake_monster_df[&#39;caught_shaggy&#39;].sum() shaggy_fake_rate = (shaggy_captured_fake / len(fake_monster_df)) * 100 #Scooby scooby_captured_fake = fake_monster_df[&#39;caught_scooby&#39;].sum() scooby_fake_rate = (scooby_captured_fake / len(fake_monster_df)) * 100 . . ## Plotting Rate of Capturing Real Monsters real_rates = np.array([fred_real_rate, daphne_real_rate, velma_real_rate, shaggy_real_rate, scooby_real_rate]) plt.pie(real_rates) plt.legend(labels = the_gang, loc = &#39;best&#39;) plt.title(&#39;Rate of Successful Real Monster Captures&#39;) plt.show() . . ## Plotting Rate of Capturing Fake Monsters fake_rates = np.array([fred_fake_rate, daphne_fake_rate, velma_fake_rate, shaggy_fake_rate, scooby_fake_rate]) plt.pie(fake_rates, autopct=&#39;%1.1f%%&#39;) plt.legend(labels = the_gang, loc = &#39;best&#39;) plt.title(&#39;Rate of Successful Fake Monster Captures&#39;) plt.show() . . According to our pie plots, Fred appears to be the most successful at capturing Fake Monsters, while Scooby Doo appears to have the highest successful capture rate of Real Monsters &amp; Fake Monsters. More importantly, it appears that Daphne &amp; Velmna have no success in capturing Real monsters. This information brings us one step further to answering our research question. . Determining the Number of Snacks each Gang member has consumed vs. the Number of Monsters they&#39;ve captured . # Total Number of Monster Captures of Each Gang Member monster_captures = np.asarray([fred_captured_fake + fred_captured_real, daphne_captured_fake + daphne_captured_real, velma_captured_fake + velma_captured_real, shaggy_captured_fake + shaggy_captured_real, scooby_captured_fake + scooby_captured_real]) snackies = np.asarray(snack_consumption) # Plotting plt.figure(figsize = (8,6)) colors = np.array([&#39;blue&#39;, &#39;orange&#39;, &#39;green&#39;, &#39;red&#39;, &#39;purple&#39;]) categories = np.array([0, 1, 2, 3, 4]) blue_patch = mpatches.Patch(color = &#39;blue&#39;, label = &#39;Fred&#39;) orange_patch = mpatches.Patch(color = &#39;orange&#39;, label = &#39;Daphne&#39;) green_patch = mpatches.Patch(color = &#39;green&#39;, label = &#39;Velma&#39;) red_patch = mpatches.Patch(color = &#39;red&#39;, label = &#39;Shaggy&#39;) purple_patch = mpatches.Patch(color = &#39;purple&#39;, label = &#39;Scooby&#39;) scatter = plt.scatter(snack_consumption, monster_captures, s= monster_captures * 10, c = colors[categories], cmap = colors) plt.xlabel(&#39;Number of Snacks Consumed&#39;) plt.legend(handles = [blue_patch, orange_patch, green_patch, red_patch, purple_patch]) plt.ylabel(&#39;Number of Monsters Captured&#39;) plt.title(&#39;Number of Monsters Captured vs. Number of Scooby Snacks Consumed&#39;) . . Text(0.5, 1.0, &#39;Number of Monsters Captured vs. Number of Scooby Snacks Consumed&#39;) . This graph represents the correlation between Scooby Snacks consumed and the Number of Monsters captured. It appears that the more Scooby Snacks consumed, the lower the number of monsters captured. Daphne, who consumed the most Scooby Snacks appears to have caught the lowest number of monsters. Alternatively, Scooby-Doo who has consumed the least amount of Scooby Snacks has caught the most number of monsters. One outlier we have is Shaggy: who has consumed the second most number of Scooby-Snacks is 3rd highest in capturing Monsters. We evaluate these results in the next section. . Discussion . This section discusses a summary of our findings and answers our research question. To reiterate, our research question is: Who is the strongest and weakest link among the Gang members of Scooby-Doo? Below is a summary of our analysis. . Who captures the most monsters, real and fake? Who captures the least? . Scooby-Doo appears to have the highest successful capture rate of monsters, both real and fake. | Daphne &amp; Velma have the lowest success rate in capturing Real Monsters. | Daphne has the lowest success rate in capturing Fake Monsters. | . Who gets abducted the most by real and fake monsters? Who gets abducted the least? . Daphne appears to get abducted the most by fake monsters. Velma gets abducted the least by fake monsters. | Scooby-Doo appears to get abducted the most by real monsters. Velma &amp; Fred get abducted the least by real monsters. | . Who eats the most Scooby-Snacks? The least? . Daphne eats the most Scooby-Snacks. | Scooby-Doo eats the least amount of Scooby-Snacks. | . Does Scooby-Snack consumption improve Monster capture capabilities? . Our results may require further research. It appears that the more Scooby Snacks one consumes, the worse their ability is to capture monsters. Daphne who has eaten the most number of Scooby Snacks has the lowest monster capture rate. While, Scooby-Doo who has eaten the least amount of Scooby Snacks has the highest monster capture rate. However one outlier we have is Shaggy, who is the 3rd best at capturing monsters but is the 2nd person that consumes the most number of Scooby Snacks. Thus, our results for this question are undetermined because Shaggy could be a special case or Scooby Snack consumption has no effect on each gang member&#39;s capabilities. A more in-depth analysis of this question may be required in order to definitively determine whether Scooby Snack consumption improves or worsens capture abilities. . Using these findings from our analysis, we are able to answer our research question. . Who is the strongest link among the Gang members of Scooby-Doo? Who is the weakest link? . Strongest Link: Scooby-Doo | Weakest Link: Daphne | . Taking real and fake monsters into consideration, we make the assumption that real monsters are more difficult to capture due to their supernatural abilities. Thus, we make the conclusion that Scooby-Doo is the strongest link among the gang members. Even though he gets abducted the most by real monsters, he has the highest capture rate for both real and fake monsters. Meaning that someway, somehow, Scooby-Doo is either extremely lucky or very powerful for subduing both powerful &amp; formidable real monsters, and fake monsters disguised as humans as well. Alternatively, we conclude that Daphne is the weakest link among the Gang members. Daphne captures the least amount of both fake and real monsters, and gets abducted the most by less powerful fake monsters. . Fan opinions may differ, but these are the results we come to based on our data. Further research may be required in order to determine why &#39;Danger Prone Daphne&#39; is an easy target for fake monsters and how Scooby-Snacks affect monster capture rates. Many fans of the series also know that Scooby-Doo has an affinity for attracting real monsters &amp; solving mysteries, but further research may also be conducted in order to determine the reasons behind his luck/unluckiness. This is just another mystery that we have on our hands. .",
            "url": "https://varshah2000.github.io/dh140-blog/scooby-doo/final%20project/2022/03/14/Final-Project-Notebook.html",
            "relUrl": "/scooby-doo/final%20project/2022/03/14/Final-Project-Notebook.html",
            "date": " • Mar 14, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Assignment 08 - Network Analysis",
            "content": "Network Visualization: All&#39;s Well That Ends Well by Shakespeare . acts = x.split(&#39;ACT&#39;)[6:11] . len(acts) . 5 . characters = [&#39;KING&#39;, &#39;DUKE&#39;, &#39;BERTRAM&#39;, &#39;LAFEW&#39;, &#39;PAROLLES&#39;, &#39;CLOWN&#39;, &#39;COUNTESS&#39;, &#39;HELENA&#39;, &#39;DIANA&#39;, &#39;MARIANA&#39; ] . charnum = {} connections = {} for i in range(len(characters)-1): for j in range(i + 1, len(characters)): connections[(characters[i], characters[j])] = 0 for k in characters: charnum[k] = 0 for i in acts: for j in i.split(&#39;SCENE&#39;)[1:]: scenechars = [] for k in characters: if j.find(k) != -1: scenechars.append(k) charnum[k] += 1 for a in range(len(scenechars)-1): for b in range(a+1, len(scenechars)): connections[(scenechars[a], scenechars[b])] += 1 . . for k,v in charnum.items(): print(k,v) . KING 4 DUKE 2 BERTRAM 11 LAFEW 7 PAROLLES 11 CLOWN 6 COUNTESS 7 HELENA 12 DIANA 4 MARIANA 1 . connections . {(&#39;KING&#39;, &#39;DUKE&#39;): 0, (&#39;KING&#39;, &#39;BERTRAM&#39;): 4, (&#39;KING&#39;, &#39;LAFEW&#39;): 3, (&#39;KING&#39;, &#39;PAROLLES&#39;): 3, (&#39;KING&#39;, &#39;CLOWN&#39;): 0, (&#39;KING&#39;, &#39;COUNTESS&#39;): 1, (&#39;KING&#39;, &#39;HELENA&#39;): 3, (&#39;KING&#39;, &#39;DIANA&#39;): 1, (&#39;KING&#39;, &#39;MARIANA&#39;): 0, (&#39;DUKE&#39;, &#39;BERTRAM&#39;): 1, (&#39;DUKE&#39;, &#39;LAFEW&#39;): 0, (&#39;DUKE&#39;, &#39;PAROLLES&#39;): 0, (&#39;DUKE&#39;, &#39;CLOWN&#39;): 0, (&#39;DUKE&#39;, &#39;COUNTESS&#39;): 0, (&#39;DUKE&#39;, &#39;HELENA&#39;): 0, (&#39;DUKE&#39;, &#39;DIANA&#39;): 0, (&#39;DUKE&#39;, &#39;MARIANA&#39;): 0, (&#39;BERTRAM&#39;, &#39;LAFEW&#39;): 5, (&#39;BERTRAM&#39;, &#39;PAROLLES&#39;): 7, (&#39;BERTRAM&#39;, &#39;CLOWN&#39;): 1, (&#39;BERTRAM&#39;, &#39;COUNTESS&#39;): 3, (&#39;BERTRAM&#39;, &#39;HELENA&#39;): 6, (&#39;BERTRAM&#39;, &#39;DIANA&#39;): 2, (&#39;BERTRAM&#39;, &#39;MARIANA&#39;): 0, (&#39;LAFEW&#39;, &#39;PAROLLES&#39;): 6, (&#39;LAFEW&#39;, &#39;CLOWN&#39;): 2, (&#39;LAFEW&#39;, &#39;COUNTESS&#39;): 3, (&#39;LAFEW&#39;, &#39;HELENA&#39;): 5, (&#39;LAFEW&#39;, &#39;DIANA&#39;): 1, (&#39;LAFEW&#39;, &#39;MARIANA&#39;): 0, (&#39;PAROLLES&#39;, &#39;CLOWN&#39;): 2, (&#39;PAROLLES&#39;, &#39;COUNTESS&#39;): 2, (&#39;PAROLLES&#39;, &#39;HELENA&#39;): 7, (&#39;PAROLLES&#39;, &#39;DIANA&#39;): 2, (&#39;PAROLLES&#39;, &#39;MARIANA&#39;): 1, (&#39;CLOWN&#39;, &#39;COUNTESS&#39;): 4, (&#39;CLOWN&#39;, &#39;HELENA&#39;): 3, (&#39;CLOWN&#39;, &#39;DIANA&#39;): 0, (&#39;CLOWN&#39;, &#39;MARIANA&#39;): 0, (&#39;COUNTESS&#39;, &#39;HELENA&#39;): 4, (&#39;COUNTESS&#39;, &#39;DIANA&#39;): 1, (&#39;COUNTESS&#39;, &#39;MARIANA&#39;): 0, (&#39;HELENA&#39;, &#39;DIANA&#39;): 3, (&#39;HELENA&#39;, &#39;MARIANA&#39;): 1, (&#39;DIANA&#39;, &#39;MARIANA&#39;): 1} . import networkx as nx import matplotlib.pyplot as plt from networkx.algorithms.community.centrality import girvan_newman . nxgraphitems = [] for k,v in connections.items(): if v != 0: dashedge = (k[0],k[1]) nxgraphitems.append(dashedge) nxgraphitems . [(&#39;KING&#39;, &#39;BERTRAM&#39;), (&#39;KING&#39;, &#39;LAFEW&#39;), (&#39;KING&#39;, &#39;PAROLLES&#39;), (&#39;KING&#39;, &#39;COUNTESS&#39;), (&#39;KING&#39;, &#39;HELENA&#39;), (&#39;KING&#39;, &#39;DIANA&#39;), (&#39;DUKE&#39;, &#39;BERTRAM&#39;), (&#39;BERTRAM&#39;, &#39;LAFEW&#39;), (&#39;BERTRAM&#39;, &#39;PAROLLES&#39;), (&#39;BERTRAM&#39;, &#39;CLOWN&#39;), (&#39;BERTRAM&#39;, &#39;COUNTESS&#39;), (&#39;BERTRAM&#39;, &#39;HELENA&#39;), (&#39;BERTRAM&#39;, &#39;DIANA&#39;), (&#39;LAFEW&#39;, &#39;PAROLLES&#39;), (&#39;LAFEW&#39;, &#39;CLOWN&#39;), (&#39;LAFEW&#39;, &#39;COUNTESS&#39;), (&#39;LAFEW&#39;, &#39;HELENA&#39;), (&#39;LAFEW&#39;, &#39;DIANA&#39;), (&#39;PAROLLES&#39;, &#39;CLOWN&#39;), (&#39;PAROLLES&#39;, &#39;COUNTESS&#39;), (&#39;PAROLLES&#39;, &#39;HELENA&#39;), (&#39;PAROLLES&#39;, &#39;DIANA&#39;), (&#39;PAROLLES&#39;, &#39;MARIANA&#39;), (&#39;CLOWN&#39;, &#39;COUNTESS&#39;), (&#39;CLOWN&#39;, &#39;HELENA&#39;), (&#39;COUNTESS&#39;, &#39;HELENA&#39;), (&#39;COUNTESS&#39;, &#39;DIANA&#39;), (&#39;HELENA&#39;, &#39;DIANA&#39;), (&#39;HELENA&#39;, &#39;MARIANA&#39;), (&#39;DIANA&#39;, &#39;MARIANA&#39;)] . G = nx.Graph() . G.add_edges_from(nxgraphitems) . G.nodes . NodeView((&#39;KING&#39;, &#39;BERTRAM&#39;, &#39;LAFEW&#39;, &#39;PAROLLES&#39;, &#39;COUNTESS&#39;, &#39;HELENA&#39;, &#39;DIANA&#39;, &#39;DUKE&#39;, &#39;CLOWN&#39;, &#39;MARIANA&#39;)) . communities = girvan_newman(G) . node_groups = [] for com in next(communities): node_groups.append(list(com)) print(node_groups) color_map = [] for node in G: if node in node_groups[0]: color_map.append(&#39;yellow&#39;) else: color_map.append(&#39;green&#39;) nx.draw(G, node_color=color_map, with_labels=True) plt.show() . . [[&#39;PAROLLES&#39;, &#39;KING&#39;, &#39;COUNTESS&#39;, &#39;HELENA&#39;, &#39;DIANA&#39;, &#39;CLOWN&#39;, &#39;LAFEW&#39;, &#39;BERTRAM&#39;], [&#39;DUKE&#39;], [&#39;MARIANA&#39;]] . nx.density(G) . 0.6666666666666666 . nx.degree_centrality(G) . {&#39;KING&#39;: 0.6666666666666666, &#39;BERTRAM&#39;: 0.8888888888888888, &#39;LAFEW&#39;: 0.7777777777777777, &#39;PAROLLES&#39;: 0.8888888888888888, &#39;COUNTESS&#39;: 0.7777777777777777, &#39;HELENA&#39;: 0.8888888888888888, &#39;DIANA&#39;: 0.7777777777777777, &#39;DUKE&#39;: 0.1111111111111111, &#39;CLOWN&#39;: 0.5555555555555556, &#39;MARIANA&#39;: 0.3333333333333333} . nx.betweenness_centrality(G) . {&#39;KING&#39;: 0.0, &#39;BERTRAM&#39;: 0.23333333333333328, &#39;LAFEW&#39;: 0.011111111111111112, &#39;PAROLLES&#39;: 0.07129629629629629, &#39;COUNTESS&#39;: 0.011111111111111112, &#39;HELENA&#39;: 0.07129629629629629, &#39;DIANA&#39;: 0.04629629629629629, &#39;DUKE&#39;: 0.0, &#39;CLOWN&#39;: 0.0, &#39;MARIANA&#39;: 0.0} . Character Network Analysis from All&#39;s Well That Ends Well . This network visualizations depicts all the speaking characters and their interactions with each other within Shakespeare&#39;s play All&#39;s Well That Ends Well. . According to our network visualization, the most important nodes are Bertram, Helena, and Parolles because they have the highest degree centrality of 0.888. In other words, these are the characters that seem to have the most interactions with the other characters and are a vital part of the social network within the play. .",
            "url": "https://varshah2000.github.io/dh140-blog/network%20analysis/shakespeare/2022/03/06/Assignment-08-Network-Analysis.html",
            "relUrl": "/network%20analysis/shakespeare/2022/03/06/Assignment-08-Network-Analysis.html",
            "date": " • Mar 6, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://varshah2000.github.io/dh140-blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://varshah2000.github.io/dh140-blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://varshah2000.github.io/dh140-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://varshah2000.github.io/dh140-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}